---
layout: post
title: redux
date: 2018-6-1
categories: react
tags: [redux]
description: 边学边记录。
---

### Flux
[http://www.ruanyifeng.com/blog/2016/01/flux.html](http://www.ruanyifeng.com/blog/2016/01/flux.html)
> 单向数据流;Flux 是一种架构思想，专门解决软件的结构问题。它跟MVC 架构是同一类东西，但是更加简单和清晰 
 Flux将一个应用分成四个部分
- View： 视图层
- Action（动作）：视图层发出的消息（比如mouseClick）
- Dispatcher（派发器）：用来接收Actions、执行回调函数
- Store（数据层）：用来存放应用的状态，一旦发生变动，就提醒Views要更新页面

![图片]({{ site.baseurl }}/img/post/flux-diagram-white-background.png)

### Redux
[http://www.redux.org.cn/](http://www.redux.org.cn/)
> 状态管理容器；Flux 架构的概念的实现；应用程序的数据称为状态
View -> Action -> Dispatcher -> Store	

- 存放应用程序状态的容器
- 一种把 action 分发到状态修改器的机制，也就是 reducer 函数
- 监听状态变化的机制

---
三大原则

- 单一数据源 - 整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中
- State 是只读的 - 唯一改变 state 的方法就是触发 action
- 使用纯函数来执行修改 - 为了描述 action 如何改变 state tree ，你需要编写 reducers

`state`
- 把所有数据放到一个对象里，每个数据以 ID 为主键，不同实体或列表间通过 ID 相互引用数据。把应用的 state 想像成数据库
{% highlight Perl %}
{
    todos: [{
        text: 'Eat food',
        completed: true
    }, {
        text: 'Exercise',
        completed: false
    }],
    visibilityFilter: 'SHOW_COMPLETED'
}
{% endhighlight %}

> 想更新 state 中的数据，你需要发起一个 action

`action`
- 把数据从View、应用传到 store 的有效载荷。它是 store 数据的唯一来源。一般来说通过 store.dispatch() 将 action 传到 store。
- 除了 type 字段外，action 对象的结构完全由自己决定
- Redux 中只需把 action 创建函数的结果传给 dispatch() 方法即可发起一次 dispatch 过程
- store 里能直接通过 store.dispatch() 调用 dispatch() 方法，但是多数情况下你会使用 react-redux 提供的 connect() 帮助器来调用
{% highlight Perl %}
{ type: 'ADD_TODO', text: 'Go to swimming pool' }
{ type: 'TOGGLE_TODO', index: 1 }
{ type: 'SET_VISIBILITY_FILTER', filter: 'SHOW_ALL' }

// 触发action
store.dispatch({
    type: 'COMPLETE_TODO',
    index: 1
})
{% endhighlight %}

> 把 action 和 state 串起来，开发一些函数，只是一个接收 state 和 action，并返回新的 state 的函数

`reducer`
- reducer 就是一个纯函数，接收旧的 state 和 action，返回新的 state
- 只要传入参数相同，返回计算得到的下一个 state 就一定相同。没有特殊情况、没有副作用，没有 API 请求、没有变量修改，单纯执行计算
{% highlight Perl %}
function todos(state = [], action) {
    switch (action.type) {
    case 'ADD_TODO':
        return state.concat([{ text: action.text, completed: false }]);
    case 'TOGGLE_TODO':
        return state.map((todo, index) => action.index === index ? { text: todo.text, completed: !todo.completed } : todo
    )
    default:
        return state;
}}
{% endhighlight %}

> 小结：首先需要注册一个全局唯一的store对象，用来维护整个应用的state；当要变更state时，我们会dispatch一个action，reducer根据action更新相应的state。

引用自[https://www.zhihu.com/question/41312576?sort=created](https://www.zhihu.com/question/41312576?sort=created)

`这是一个模块化的项目，这是它的模块“间”通信`
![图片]({{ site.baseurl }}/img/post/react-redux-01.jpg)

`https://www.zhihu.com/question/41312576?sort=created`
![图片]({{ site.baseurl }}/img/post/react-redux-02.jpg)

这类架构目的是类似的：更好维护的模块间通信。
action 这些是由模块发起的通信请求，其实就是一个数据对象
reducer 就是方块内部对这些数据对象的筛选处理过程

### Redux-saga
[https://redux-saga-in-chinese.js.org/](https://redux-saga-in-chinese.js.org/)
> 用于管理 action，处理异步逻辑。redux-saga 是一个 redux 的中间件

![图片]({{ site.baseurl }}/img/post/React+Redux.png)
React+Redux Cycle(来源：https://www.youtube.com/watch?v=1QI-UE3-0PU)